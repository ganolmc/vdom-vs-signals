# Benchmark Results - August 22, 2025

**Run ID**: 2025-08-22T03-54  
**Generated**: 2025-08-22T05:06:23.125Z  
**Sample Size**: 10 runs per scenario per framework (120 total measurements)

## Executive Summary

This benchmark demonstrates significant performance advantages for Solid.js over React across all measured metrics:

- **DOM Mutations**: 99.9% reduction (Solid vs React)
- **Memory Usage**: 70-75% reduction in heap consumption
- **Update Latency**: 30-94% improvement in operation speed
- **Long Tasks**: Reduced blocking task frequency and duration

## Detailed Results

### DOM Mutations Comparison

DOM mutations represent the actual changes made to the Document Object Model, measured via MutationObserver API.

| Scenario | React (Median) | Solid (Median) | Improvement Ratio |
|----------|----------------|----------------|-------------------|
| S1_FILTER | 10,007 | 3 | 3,336:1 |
| S2_UPDATE_1PCT | 25,168 | 52 | 484:1 |
| S3_INSERT_1K | 11,007 | 3 | 3,669:1 |
| S4_REMOVE_1K | 11,010 | 3 | 3,670:1 |
| S5_SORT_COL | 101,997 | 7 | 14,571:1 |
| S6_IDLE_30S | 10,005 | 2 | 5,003:1 |

**Key Insights:**

- Solid.js achieves near-minimal DOM mutations across all scenarios
- React's Virtual DOM creates substantial overhead even for simple operations
- Most dramatic difference in S5_SORT_COL (sorting operations)

### Update Latency Analysis

Update latency measures the time required to complete each scenario operation.

| Scenario | React Median (ms) | React P95 (ms) | Solid Median (ms) | Solid P95 (ms) | Improvement |
|----------|-------------------|----------------|-------------------|----------------|-------------|
| S1_FILTER | 1,035 | 1,323 | 473 | 560 | 54.3% faster |
| S2_UPDATE_1PCT | 8,298 | 9,371 | 541 | 669 | 93.5% faster |
| S3_INSERT_1K | 1,554 | 1,653 | 759 | 857 | 51.2% faster |
| S4_REMOVE_1K | 1,361 | 15,360 | 661 | 837 | 51.4% faster |
| S5_SORT_COL | 4,948 | 5,688 | 3,083 | 3,358 | 37.7% faster |
| S6_IDLE_30S | 1,036 | 1,091 | 720 | 973 | 30.5% slower |

**Key Insights:**

- Most significant improvement in S2_UPDATE_1PCT (continuous updates)
- React shows high P95 variance in S4_REMOVE_1K (15.36s vs 1.36s median)
- Only scenario where Solid is slower: S6_IDLE_30S (idle monitoring)

### Memory Consumption (Heap Size)

JavaScript heap memory usage measured at scenario completion.

| Scenario | React Median (MB) | React P95 (MB) | Solid Median (MB) | Solid P95 (MB) | Memory Reduction |
|----------|-------------------|----------------|-------------------|----------------|------------------|
| S1_FILTER | 264.68 | 441.04 | 75.80 | 121.55 | 71.4% |
| S2_UPDATE_1PCT | 748.22 | 955.88 | 199.74 | 248.16 | 73.3% |
| S3_INSERT_1K | 1,235.10 | 1,417.45 | 322.25 | 374.85 | 73.9% |
| S4_REMOVE_1K | 1,659.76 | 1,817.85 | 441.23 | 485.65 | 73.4% |
| S5_SORT_COL | 2,133.75 | 2,329.08 | 559.64 | 605.78 | 73.8% |
| S6_IDLE_30S | 2,472.70 | 2,568.36 | 675.05 | 722.94 | 72.7% |

**Key Insights:**

- Consistent 70-75% memory reduction across all scenarios
- React memory usage grows significantly with data complexity
- Solid maintains more efficient memory profile throughout

### Long Task Performance

Long tasks are JavaScript execution periods exceeding 50ms that can block the main thread.

| Scenario | React Count | React Duration (ms) | Solid Count | Solid Duration (ms) | Task Reduction |
|----------|-------------|---------------------|-------------|---------------------|----------------|
| S1_FILTER | 2 | 1,035 | 1 | 473 | 50% fewer tasks |
| S2_UPDATE_1PCT | 51 | 8,298 | 1 | 541 | 98% fewer tasks |
| S3_INSERT_1K | 2 | 1,554 | 2 | 759 | Same count, 51% shorter |
| S4_REMOVE_1K | 2 | 1,361 | 1 | 661 | 50% fewer tasks |
| S5_SORT_COL | 6 | 4,948 | 7 | 3,083 | Similar count, 38% shorter |
| S6_IDLE_30S | 1 | 1,036 | 1 | 720 | Same count, 31% shorter |

**Key Insights:**

- Most dramatic improvement in S2_UPDATE_1PCT (98% fewer blocking tasks)
- Solid generally produces fewer and shorter blocking operations
- S5_SORT_COL shows similar task count but significantly shorter duration

## Performance Analysis by Scenario

### S1_FILTER (Region Filter Change)

- **React**: 10,007 DOM mutations for a simple dropdown change
- **Solid**: 3 DOM mutations for the same operation
- **Analysis**: React's Virtual DOM reconciliation creates massive overhead for minimal UI changes

### S2_UPDATE_1PCT (Incremental Updates)

- **React**: 25,168 DOM mutations, 51 long tasks over 8.3 seconds
- **Solid**: 52 DOM mutations, 1 long task in 0.54 seconds
- **Analysis**: Solid's fine-grained reactivity excels at continuous updates

### S3_INSERT_1K (Bulk Insertion)

- **React**: 11,007 DOM mutations, 1.55 seconds
- **Solid**: 3 DOM mutations, 0.76 seconds
- **Analysis**: Solid's efficient list rendering vs React's full reconciliation

### S4_REMOVE_1K (Bulk Removal)

- **React**: 11,010 DOM mutations, highly variable performance (P95: 15.36s)
- **Solid**: 3 DOM mutations, consistent performance
- **Analysis**: React struggles with large-scale DOM cleanup

### S5_SORT_COL (Complex Sorting)

- **React**: 101,997 DOM mutations (highest of all scenarios)
- **Solid**: 7 DOM mutations
- **Analysis**: Most extreme difference - React rebuilds entire lists, Solid updates minimally

### S6_IDLE_30S (Baseline)

- **React**: 10,005 DOM mutations during idle period
- **Solid**: 2 DOM mutations during idle period
- **Analysis**: React has ongoing background activity, Solid remains truly idle

## Technical Implementation

### Measurement Methodology

- **Browser**: Puppeteer-controlled Chromium
- **DOM Mutations**: MutationObserver with subtree, childList, attributes, and characterData monitoring
- **Memory**: Chrome DevTools Memory API (usedJSHeapSize)
- **Long Tasks**: PerformanceObserver monitoring tasks >50ms
- **Sample Size**: 10 independent runs per scenario

### Framework Implementations

- **React**: Standard hooks (useState, useEffect), Virtual DOM reconciliation
- **Solid**: Fine-grained signals, direct DOM updates, no Virtual DOM
- **Shared**: Identical UI components, styling, and data structures

## Conclusions

This benchmark demonstrates fundamental architectural differences between Virtual DOM and signals-based reactivity:

1. **DOM Efficiency**: Solid's 99.9% reduction in DOM mutations represents a paradigm shift toward surgical updates
2. **Memory Management**: Consistent 70-75% memory reduction indicates more efficient object lifecycle management
3. **Execution Performance**: 30-94% latency improvements, especially in continuous update scenarios
4. **User Experience**: Fewer and shorter blocking tasks result in more responsive interfaces

The results suggest that fine-grained reactivity systems like Solid.js offer significant performance advantages for data-intensive applications, particularly those requiring frequent updates or operating in memory-constrained environments.
